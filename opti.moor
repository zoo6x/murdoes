
\\ Optimizer
\
								\\ Debug output
: ..S .S ;
: .S blue ..S norm ;						\ Blue stack

								\\ Regallocing and assembling states
: (%>)     | INTERPRETING >cfa@ >>> REGALLOCING >< does ;	\ ( xt -- )		Sets word's register allocation semantics to its execution semantics
: %>       ' (%>) ;						\ ( "<name>" -- )	Sets register allocation semantics to execution semantics
: <%       latest (%>) ;					\ ( -- )		Sets latest word's register allocation semantics to execution semantics

: (:)      : ;							\ 			Redefine : to enable REGALLOCING state
: :        (:) <% ;

: ($>)     | INTERPRETING >cfa@ >>> ASSEMBLING >< does ;	\ ( xt -- )		Sets word's register allocation semantics to its execution semantics
: $>       ' ($>) ;						\ ( "<name>" -- )	Sets register allocation semantics to execution semantics
: <$       latest ($>) ;					\ ( -- )		Sets latest word's register allocation semantics to execution semantics

: INTERPRETING! INTERPRETING state! ;

: REGALLOCING! REGALLOCING state! ;
:: REGALLOCING!!  code rstate REGALLOCING mov.i, ret, <% <$	\ ( -- )		Sets state to REGALLOCING without address interpreter involvement

: ASSEMBLING! ASSEMBLING state! ;
:: ASSEMBLING!!  code rstate ASSEMBLING mov.i, ret, <%		\ ( -- )		Sets state to ASSEMBLING without address interpreter involvement

: DEALLOCING! DEALLOCING state! ;
:: DEALLOCING!!  code rstate DEALLOCING mov.i, ret, <%		\ ( -- )		Sets state to DEALLOCING without address interpreter involvement

: regalloc REGALLOCING! execute interpreting! INTERPRETING! ;	\ ( xt -- )		Sets STATE to REGALLOCING for the XT 

: :%       : compile interpreting! ;

								\\ Register allocation
:: #regs   10 val						\ Number of CPU registers
:: regs    adr #regs allot					\ Register alias count
: ^        regs + | c@ 1+ >< c! ; 				\ ( r -- )		Increments reference count for a register. TODO: Add overflow/underflow checks
: v        regs + | c@ | if 1- >< c!				\ ( r -- )		Decrements reference count for a register
           else .. a11a501 .abort then ; 
: v^       regs + | c@ | if 1- | if >< c! 0 else _ _ 1 then 	\ ( r -- 1|0 )		If register is not aliased, then it can be reused
           else a11a502 .abort then ; 
								\ 			otherwise decrement reference count and return 0
: ?^       regs #regs for | c@ I >< leave _ 1+ over			\ ( -- r | ABORT )	Allocates a new register, if one is available
           0add bada110c .abort
           then >< _ #regs >< - | ^ ;
: ∧        | ^ ;						\ ( r -- r )		Increments reference count for a register, leaving register on the stack
: ∨        v ;
: |∨       | v ;						\ ( r -- r )		Decrement reference count for a register, leaving register on the stack
: ∨∧       | v^ ;						\ ( r -- r 1|0 )	Free register and reallocate it, if it's not aliased

: .regs    regs #regs for | c@ .. 1+ over _ ;

								\\ Stacks for control structures
: dirupload >< | { | for | { I - 1+ #| >| >s } over _ } | <<< >< >s  ; \ ( an ... a1 n s -- a1 ... an n )  Copy N elements from data stack onto the specified stack
: revupload >< | { for | I 1+ #| >< >s over } | <<< >< >s  ;	\ ( an ... a1 n s -- an ... a1 n )  Copy N elements from data stack onto the specified stack

: offload   for ∨ over ;
: diroffload dirupload offload ;				\ ( an ... a1 n s -- an ... a1 n )  Push N elements from data stack onto the specified stack
: revoffload revupload offload ;

: download  | s> | { for | s> ∧ >< over _ } ;			\ ( s -- a1 ... an n ) (s: a1 ... an n -- ) Pop N elements off the specified stack onto the data stack
: onload  | s> | { for | s> >< over _ } ;			\ ( s -- a1 ... an n ) (s: a1 ... an n -- ) Pop N elements w/o changing references

:: tmp-stack 100 stack						\ Temporary stack, for transfers between other stacks
: >tmp    tmp-stack >s ;
: tmp>    tmp-stack s> ;

:: ret-stack 100 stack						\ Return stack
: >ret    ret-stack >s ;
: ret>    ret-stack s> ;

:: cyc-stack 100 stack						\ Cycle stack
: >cyc    cyc-stack >s ;
: cyc>    cyc-stack s> ;

:: phi-stack 100 stack						\ Phi junction stack
: >phi    phi-stack >s ;
: phi>    phi-stack s> ;

:: opt-index        0 var					\ Index inside current word, for branch visualization
:: opt-lit          0 var					\ Holds 1-cell literal, offset or other data between regallocing and assembling
:: opt-xt           0 var					\ Holds XT of the currently executing REGALLOCING/ASEMBLING word
:: opt-branch       0 var					\ Holds latest branch offset
:: opt-phi-move     0 var					\ Flag indicating whether φ requires moving regiters
:: opt-phi-temp-reg 0 var					\ Temporary register for φ moves
:: opt-phi-save-reg 0 var					\ Saved register for φ moves
:: opt-phi-dest-reg 0 var					\ Register to be assigned from the saved register
:: opt-phi-forward  0 var					\ Flag indicating whether the φ-junction is forward or backward

: %.debug 							\ ( xt -- )		Debug print word name and stack
           cr
	   opt-index @ purple . norm
           1b emit 5b emit 30 emit 34 emit 47 emit
           >name count white type norm

           1b emit 5b emit 31 emit 33 emit 47 emit ;
: %.S      
           1b emit 5b emit 31 emit 39 emit 47 emit
           ..S
           1b emit 5b emit 33 emit 39 emit 47 emit
	   .regs 
           1b emit 5b emit 37 emit 32 emit 47 emit
	   52 emit 3a emit bl emit ret-stack .stack
           1b emit 5b emit 37 emit 39 emit 47 emit
	   43 emit 3a emit bl emit cyc-stack .stack
           1b emit 5b emit 38 emit 38 emit 47 emit
	   cf emit 86 emit 3a emit bl emit phi-stack .stack
           1b emit 5b emit 31 emit 30 emit 39 emit 47 emit
	   54 emit 3a emit bl emit tmp-stack .stack
           1b emit 5b emit 31 emit 31 emit 38 emit 47 emit
           ." |  " 
	   ;

								\\ Regallocing semantics definitions
: noop ;

: $        here (exec) ASSEMBLING ' | >r does r> _		\ ( "<name>" --  )	Creates new semantics for assembling state
           compile interpreting!
	   ] ;
: $;       compile ASSEMBLING!! compile exit [compile] [ ; immediate

$ noop     $;

' exit INTERPRETING >cfa@ REGALLOCING ' exit does
' exit INTERPRETING >cfa@ ASSEMBLING ' exit does
' exit INTERPRETING >cfa@ DEALLOCING ' exit does

' interpreting! INTERPRETING >cfa@ REGALLOCING ' interpreting! does
' interpreting! INTERPRETING >cfa@ ASSEMBLING ' interpreting! does
' interpreting! INTERPRETING >cfa@ DEALLOCING ' interpreting! does

: assm     ;
$ assm     $;

: %        here (exec) REGALLOCING ' | >r does 			\ ( "<name>" --  )	Creates new semantics for register allocation state,
           ['] assm ASSEMBLING   >cfa@ ASSEMBLING r> | >r does
           ['] assm INTERPRETING >cfa@ DEALLOCING r> | >r does r>
           compile interpreting! 				\			which equals to execution semantics of its constituents
	   | opt-xt !
	   [compile] literal
	   compile %.debug					\ DEBUG
           ] ;

: %;       compile %.S						\ DEBUG

	   compile opt-index
	   compile 1+!
	   
	   compile >tmp
           compile ASSEMBLING!!
           opt-xt @
	   compile,
	   compile interpreting!
	   compile tmp>
           
           compile DEALLOCING!!
           opt-xt @
	   compile,
	   compile interpreting!

	   compile REGALLOCING!!

	   compile exit [compile] [ ; immediate

: ;%								\			Finish REGALLOCING definition and start DEALLOCING definition
           [compile] %;
           here (exec) DEALLOCING opt-xt @ does
	   compile interpreting!
	   ] ; immediate
	  
: ;%;      	  
	   compile REGALLOCING!!

	   compile exit [compile] [ ; immediate

% noop %;
	   							\\ Register allocation primitives
: ?∧       ?^ ;
: ⊻        1- { ∨ } ;						\ ( r # -- #-1 )	Frees a register

: regs-init							\ ( -- )		Initializes array of referenced registers
           regs #regs 0 fill
	   tmp-stack empty
	   ret-stack empty
	   cyc-stack empty
	   phi-stack empty
           rsp ∧ _						\ 			RSP should not be used as a general-purpose register
;
								\\ Syntactic sugar
: :^       regs-init ;
: ^>
           cr %.S 
	   0 opt-index !
	   ' regalloc 
	   ['] exit %.debug %.S ;

								\\ Register allocation
% |        norm 1+ { | ∧ } %;					\ ( r # -- r r #+1 )	Duplicates register (creates an alias)
% _        ⊻ %;							\ ( r # -- #-1)

% ><       { >< } %;						\ ( r1 r2 # -- r2 r2 # )
% <<<      { <<< } %;						\ ( r1 r2 r3 # -- r3 r1 r2 # )
% >>>      { >>> } %;						\ ( r1 r2 r3 # -- r2 r3 r1 # )
% >|       1+ { >| ∧ } %;				 	\ ( r1 r2 # -- r1 r2 r1 #+1 )
% >>|      1+ { >>| ∧ } %;				 	\ ( r1 r2 r3 # -- r1 r2 r3 r1 #+1 )
% >|>|     1+ 1+ { >|>| ∧ >< ∧ >< } %;

% >r       1- { >ret } %;
% r>       1+ { ret> } %;


% lit      @skip | opt-lit ! opt-index 1+! .. 1+ { ?∧ } %;	\ ( # -- r #+1 )	Allocates new register
$ lit      green ." mov" tab yellow ." r" | . bs ." , " opt-lit @ .. norm $;

% branch   @skip | opt-branch ! opt-index 1+! .. %;		\ ( -- )
% ?branch  @skip | opt-branch ! opt-index 1+! .. ⊻ %;		\ ( r # -- #-1 )
% -?branch @skip | opt-branch ! opt-index 1+! .. ⊻ %;		\ ( r # -- #-1 )

% (if)     >< { 1- phi-stack revupload } >< 1+ %;		\			Upload stack as if after ?BRANCH
% (else-pre) tmp-stack diroffload %;
% (else-post) phi-stack download phi-stack revoffload phi-stack download tmp-stack download phi-stack revoffload %;
% (then)   %;
% (begin)  %;
% (until)  %;
% (again)  %;
% (ahead)  %;
% (while)  %;
% (leave)  %;
% (repeat) %;
% (continue) %;
% (break) %;
% (for)    1- { >cyc } phi-stack revupload %;			\ ( r # -- #-1 )	Takes counter off the stack TODO: Save counter on another stack
% I        1+ { cyc> ∧ | >cyc } %;
% (over)   @skip | opt-branch ! opt-index 1+! .. ;% cyc> ∨ ;%;					\ ( -- )
% (over-post) %;

% +        1+ { 						\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
           >< ∨∧ if | <<< >< |∨ >< else				\			Try to allocate rs1 as rd, then rs2, then a new register
	   >< ∨∧ if | else 
	   ?∧ then then
           | >tmp } ;% 1- 1- tmp> >< ;%;			\ ( -- rd #-1 )

% -        1+ { 						\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
           >< ∨∧ if | <<< >< |∨ >< else				\			Try to allocate rs1 as rd, then rs2, then a new register
	   >< ∨∧ if | else 
	   ?∧ then then
           | >tmp } ;% 1- 1- tmp> >< ;%;			\ ( -- rd #-1 )

% 1+       %;							\ 			Increment and decrement do not change register allocation
% 1-       %;

% ,        ⊻ %;							\ ( r # -- #-1 )	Frees the parameter
% emit     ⊻ %;							\ ( r # -- #-1 )	Frees the parameter 

								\\ Assembling
								\ TODO: Symmetric operations might favor register with lower index rather then RS1
								\ Is it possible to determine an optimal local strategy?
$ +        >>> >|>| - if <<< >|>| -				\ ( rs1 rs2 rd -- )	Assemble +
           if							\			RD <> RS1, RS2
	   >>> >< green ." mov" tab yellow ." r" | . bs ." , r" >< . norm cr %.S green ." add" tab yellow ." r" . bs ." , r" . bs norm 
           else							\			RD = RS2
           _ green ." add" tab yellow ." r" . bs ." , r" . bs norm
	   then
	   else							\			RD = RS1
           >< _ green ." add" tab yellow ." r" . bs ." , r" . bs norm
	   then $;

$ -        >>> >|>| - if <<< >|>| -
           if							\			RD <> RS1, RS2
	   >>> >< green ." mov" tab yellow ." r" | . bs ." , r" >< . norm cr %.S green ." sub" tab yellow ." r" . bs ." , r" . bs norm 
	   else							\			RD = RS2
	   >< _ green ." sub" tab yellow ." r" | . bs ." , " ." r" >< . bs cr %.S green ." neg " tab yellow ." r" . bs norm
	   then
	   else							\			RD = RS1
	   >< _ green ." sub" tab yellow ." r" . bs ." , " ." r" . bs norm
	   then  $;

$ 1+       green ." inc" tab yellow ." r" . bs norm $;
$ 1-       green ." dec" tab yellow ." r" . bs norm $;

$ (if)     green ." test" tab yellow ." r" | . bs ." , " ." r" | . bs norm $;
$ ?branch  green ." jz " tab opt-branch @ opt-index @ + purple . norm $;
$ -?branch green ." jnz" tab opt-branch @ opt-index @ + purple . norm $;
$ branch   green ." jmp" tab opt-branch @ opt-index @ + purple . norm $;

\ φ-junction
\ 2 3 1 -- 1 2 3

: φ
           1 opt-phi-move !
	   -1 opt-phi-save-reg !
           tmp> | >tmp | phi> | >phi 
	   - if
	   fee bad57ac .abort else
           phi-stack download phi-stack dirupload phi-stack diroffload 
	   tmp-stack dirupload
	   _
	   phi> for
	   phi> >|>| 
	   opt-phi-forward @ if >< then
	   - if
	   opt-phi-move @ if
           0 opt-phi-move !
	   ?∧ opt-phi-temp-reg ! 
	   | opt-phi-temp-reg @ - if
	   green ." mov!" tab yellow ." r" opt-phi-temp-reg @ . bs ." , r" | . norm cr %.S
	   green ." mov@" tab yellow ." r" . bs ." , r" . norm cr %.S
	   then
	   | opt-phi-save-reg ! |
	   then
           >| opt-phi-save-reg @ - if
	   green ." mov" tab yellow ." r" . bs ." , r" . norm cr %.S
	   else
	   | opt-phi-dest-reg !
	   then
	   else _ _ then 
	   over
	   opt-phi-save-reg @ 1+ if
	   green ." mov#" tab yellow ." r" opt-phi-dest-reg @ . bs ." , r" opt-phi-temp-reg @ . norm cr %.S
	   then
	   opt-phi-move @ if else opt-phi-temp-reg @ ∨ then
	   opt-phi-forward @ if tmp-stack onload offload else tmp-stack onload then
	   phi-stack onload 
	   opt-phi-forward @ if phi-stack revupload #_ phi-stack download else #_ then
	   _
           then ;

: <φ       0 opt-phi-forward ! φ ;
: >φ       1 opt-phi-forward ! φ ;

$ (over)   
           green ." dec" cyc> | >cyc tab yellow ." r" . norm cr %.S green ." jz" tab opt-index @ 1+ purple . norm cr %.S
           <φ
           cr %.S green ." jmp" tab opt-branch @ opt-index @ + purple . norm $;

$ (then)   >φ $;

								\\ Simpler examples, w/o Phi junctions
: cs-for0 0 >< for I + over ;
1 cs-for0 .. 
2 cs-for0 .. 
ff cs-for0 .. 


: q - + ;
1 2 3 q ..
: qq 1 2 3 q ;
qq ..
cold
:^ ?^ ?^ ?^ 3 ^> q 
#_
:^ 0 ^> qq 
#_
: q >| { + + } + ;
:^ ?^ ?^ ?^ 3 ^> q 
#_
: q >|>| { { + + } } + >< + ;
:^ ?^ ?^ ?^ 3 ^> q 
#_
: q >|>| { { - + } } - >< - ;
:^ ?^ ?^ ?^ 3 ^> q 
#_

: cs-for0 0 >< for I + over ;
1 cs-for0 .. 
2 cs-for0 .. 
ff cs-for0 .. 

cold
:^ ?^ 1 ^> cs-for0 
#_

cold
: cs-if0 1 >< | if + else - then noop ;
: cs-if1 1 >< | if 11 + else - 55 then + ;
: cs-if2 1 >< | if >< then noop - ;
0 cs-if0 .. 
1 cs-if0 .. 
2 cs-if0 .. 
0 cs-if1 .. 
1 cs-if1 .. 
2 cs-if1 .. 
0 cs-if2 .. 
1 cs-if2 .. 
2 cs-if2 .. 
cold
:^ ?^ 1 ^> cs-if2 
cold
:^ ?^ 1 ^> cs-if0 
#_
bad c0de .abort

cold
:^ ?^ 1 ^> cs-if1 
#_

: cs-for1 { 0 1 2 } for I + <<< over - + ;
1 cs-for1 ..
2 cs-for1 ..
3 cs-for1 ..
4 cs-for1 ..
5 cs-for1 ..
ff cs-for1 ..
cr
:^ ?^ 1 ^> cs-for1 
#_


cold
: fib      | if 0 1 >>> for >| + >< over _ then ;
cold
0 fib ..  
1 fib ..  
2 fib ..  
3 fib ..  
4 fib ..  
5 fib ..  
6 fib ..  
7 fib ..  
8 fib ..  
9 fib ..  

see fib

cold
:^ ?^ 1 ^> fib 
#_  

cold
: cs-if3 { 11 22 33 } if <<< then - + noop ;
0 cs-if3 ..
1 cs-if3 ..
:^ ?^ 1 ^> cs-if3

% cr %;
% ?? %;
% .S %;

: fib3     | if { 0 1 2 } for cr .S >>> >>| >>| 7c emit .S + + over <<< _ _ then noop ;
cold
0 fib3 ..  
1 fib3 ..  
2 fib3 ..  
3 fib3 ..  
4 fib3 ..  
5 fib3 ..  
6 fib3 ..  
7 fib3 ..  
8 fib3 ..  
9 fib3 ..  

cold
:^ ?^ 1 ^> fib3


cold
: cs4 3 begin 30 emit 1- | continue 31 emit >< | break 32 emit | 1+ while 33 emit _ 1 1 repeat 34 emit then 35 emit ;
\ : cs5 41 3 begin 30 emit { 1+ ?? } 1- | continue 31 emit { 1+ ?? } 2 pick break 32 emit { 1+ ?? } | while 33 emit { 1+ ?? } repeat 34 emit { 1+ ?? } then _ 35 emit emit _ 36 emit ;
: cs5 41 3 begin 30 emit .S { 1+ } 1- | continue 31 emit .S { 1+ } >>| break 32 emit { 1+ } | 1+ while .S 33 emit _ >< _ 1 >< 2 .S repeat 34 emit { 1+ } then _ 35 emit red emit norm _ 36 emit ;
: cs50 41 3 begin { 1+ } 1- | continue { 1+ } >>| break { 1+ } | 1+ while _ >< _ 1 >< 2 repeat { 1+ } then _ emit _ ;
0 cs4 
1 cs4
cold
0 cs5 .S 
cold
1 cs5 .S 
cold
0 cs50 .S 
cold
1 cs50 .S 
cold
:^ ?^ 1 ^> cs50 #_


600df00d 0c0de .abort

