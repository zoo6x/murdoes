\
\\ Optimizer
\
								\\ Debug output
: ..S .S ;
: .S blue ..S norm ;						\ Blue stack

								\\ Regallocing and assembling states
: (%>)     | INTERPRETING >cfa@ >>> REGALLOCING >< does ;	\ ( xt -- )		Sets word's register allocation semantics to its execution semantics
: %>       ' (%>) ;						\ ( "<name>" -- )	Sets register allocation semantics to execution semantics
: <%       latest (%>) ;					\ ( -- )		Sets latest word's register allocation semantics to execution semantics

: (:)      : ;							\ 			Redefine : to enable REGALLOCING state
: :        (:) <% ;

: ($>)     | INTERPRETING >cfa@ >>> ASSEMBLING >< does ;	\ ( xt -- )		Sets word's register allocation semantics to its execution semantics
: $>       ' ($>) ;						\ ( "<name>" -- )	Sets register allocation semantics to execution semantics
: <$       latest ($>) ;					\ ( -- )		Sets latest word's register allocation semantics to execution semantics

: INTERPRETING! INTERPRETING state! ;

: REGALLOCING! REGALLOCING state! ;
:: REGALLOCING!!  code rstate REGALLOCING mov.i, ret, <% <$	\ ( -- )		Sets state to REGALLOCING without address interpreter involvement

: ASSEMBLING! ASSEMBLING state! ;
:: ASSEMBLING!!  code rstate ASSEMBLING mov.i, ret, <%		\ ( -- )		Sets state to ASSEMBLING without address interpreter involvement

: DEALLOCING! DEALLOCING state! ;
:: DEALLOCING!!  code rstate DEALLOCING mov.i, ret, <%		\ ( -- )		Sets state to DEALLOCING without address interpreter involvement

: regalloc REGALLOCING! ' execute interpreting! INTERPRETING! ;	\ ( -- )		Sets STATE to REGALLOCING for the next text interpreter word 

: :%       : compile interpreting! ;

								\\ Register allocation
:: #regs   10 val						\ Number of CPU registers
:: regs    adr #regs allot					\ Register alias count
: ^        regs + | c@ 1+ >< c! ; 				\ ( r -- )		Increments reference count for a register. TODO: Add overflow/underflow checks
: v        regs + | c@ | if 1- >< c!				\ ( r -- )		Decrements reference count for a register
           else a11a501 .abort then ; 
: v^       regs + | c@ | if 1- | if >< c! 0 else _ _ 1 then 	\ ( r -- 1|0 )		If register is not aliased, then it can be reused
           else a11a502 .abort then ; 
								\ 			otherwise decrement reference count and return 0
: ?^       regs #regs for | c@ leave 1+ over			\ ( -- r | ABORT )	Allocates a new register, if one is available
           0add bada110c .abort
           then _ #regs I - | ^ ;
: ∧        | ^ ;						\ ( r -- r )		Increments reference count for a register, leaving register on the stack
: ∨        v ;
: |∨       | v ;						\ ( r -- r )		Decrement reference count for a register, leaving register on the stack
: ∨∧       | v^ ;						\ ( r -- r 1|0 )	Free register and reallocate it, if it's not aliased

: .regs    regs #regs for | c@ .. 1+ over _ ;

								\\ Stacks for control structures
: dirupload >< | { | for | { I - 1+ #| >| >s } over _ } | <<< >< >s  ; \ ( an ... a1 n s -- a1 ... an n )  Copy N elements from data stack onto the specified stack
: revupload >< | { for | I 1+ #| >< >s over } | <<< >< >s  ;	\ ( an ... a1 n s -- an ... a1 n )  Copy N elements from data stack onto the specified stack

: offload   for ∨ over ;
: diroffload dirupload offload ;				\ ( an ... a1 n s -- an ... a1 n )  Push N elements from data stack onto the specified stack
: revoffload revupload offload ;

: download  | s> | { for | s> ∧ >< over _ } ;			\ ( s -- a1 ... an n ) (s: a1 ... an n -- ) Pop N elements off the specified stack onto the data stack
: onload  | s> | { for | s> >< over _ } ;			\ ( s -- a1 ... an n ) (s: a1 ... an n -- ) Pop N elements w/o changing references

:: tmp-stack 100 stack						\ Temporary stack, for transfers between other stacks
: >tmp    tmp-stack >s ;
: tmp>    tmp-stack s> ;

:: ret-stack 100 stack						\ Return stack
: >ret    ret-stack >s ;
: ret>    ret-stack s> ;

:: cyc-stack 100 stack						\ Cycle stack
: >cyc    cyc-stack >s ;
: cyc>    cyc-stack s> ;

:: phi-stack 100 stack						\ Phi junction stack
: >phi    phi-stack >s ;
: phi>    phi-stack s> ;

:: opt-index  0 var						\ Index inside current word, for branch visualization
:: opt-lit    0 var						\ Holds 1-cell literal, offset or other data between regallocing and assembling
:: opt-xt     0 var						\ Holds XT of the currently executing REGALLOCING/ASEMBLING word
:: opt-branch 0 var						\ Holds latest branch offset

: %.debug 							\ ( xt -- )		Debug print word name and stack
           cr
	   opt-index @ purple . norm
           1b emit 5b emit 30 emit 33 emit 47 emit
           >name count white type norm

           1b emit 5b emit 31 emit 31 emit 47 emit ;
: %.S      
           1b emit 5b emit 31 emit 35 emit 47 emit
           ..S
           1b emit 5b emit 33 emit 34 emit 47 emit
	   .regs 
           1b emit 5b emit 36 emit 37 emit 47 emit
	   52 emit 3a emit bl emit ret-stack .stack
           1b emit 5b emit 37 emit 35 emit 47 emit
	   43 emit 3a emit bl emit cyc-stack .stack
           1b emit 5b emit 38 emit 33 emit 47 emit
	   cf emit 86 emit 3a emit bl emit phi-stack .stack
           1b emit 5b emit 31 emit 30 emit 35 emit 47 emit
           ." |  " 
	   ;

								\\ Regallocing semantics definitions
: noop ;

: $        here (exec) ASSEMBLING ' | >r does r> _		\ ( "<name>" --  )	Creates new semantics for assembling state
           compile interpreting!
	   ] ;
: $;       compile ASSEMBLING!! compile exit [compile] [ ; immediate

$ noop     $;

' exit INTERPRETING >cfa@ REGALLOCING ' exit does
' exit INTERPRETING >cfa@ ASSEMBLING ' exit does
' exit INTERPRETING >cfa@ DEALLOCING ' exit does

' interpreting! INTERPRETING >cfa@ REGALLOCING ' interpreting! does
' interpreting! INTERPRETING >cfa@ ASSEMBLING ' interpreting! does
' interpreting! INTERPRETING >cfa@ DEALLOCING ' interpreting! does

: assm     ;
$ assm     $;

: %        here (exec) REGALLOCING ' | >r does 			\ ( "<name>" --  )	Creates new semantics for register allocation state,
           ['] assm ASSEMBLING   >cfa@ ASSEMBLING r> | >r does
           ['] assm INTERPRETING >cfa@ DEALLOCING r> | >r does r>
           compile interpreting! 				\			which equals to execution semantics of its constituents
	   | opt-xt !
	   [compile] literal
	   compile %.debug					\ DEBUG
           ] ;

: %;       compile %.S						\ DEBUG

	   compile opt-index
	   compile 1+!
	   
	   compile >tmp
           compile ASSEMBLING!!
           opt-xt @
	   compile,
	   compile interpreting!
	   compile tmp>
           
           compile DEALLOCING!!
           opt-xt @
	   compile,
	   compile interpreting!

	   compile REGALLOCING!!

	   compile exit [compile] [ ; immediate

: ;%								\			Finish REGALLOCING definition and start DEALLOCING definition
           [compile] %;
           here (exec) DEALLOCING opt-xt @ does
	   compile interpreting!
	   ] ; immediate
	  
: ;%;      	  
	   compile REGALLOCING!!

	   compile exit [compile] [ ; immediate

% noop %;
	   							\\ Register allocation primitives
: ?∧       ?^ ;
: ⊻        1- { ∨ } ;						\ ( r # -- #-1 )	Frees a register

: regs-init							\ ( -- )		Initializes array of referenced registers
           regs #regs 0 fill
	   tmp-stack empty
	   ret-stack empty
	   cyc-stack empty
	   phi-stack empty
           rsp ∧ _						\ 			RSP should not be used as a general-purpose register
;
								\\ Syntactic sugar
: :^       regs-init ;
: ^>
           cr %.S 
	   0 opt-index !
	   regalloc
	   cr %.S ;

								\\ Register allocation
% |        norm 1+ { | ∧ } %;					\ ( r # -- r r #+1 )	Duplicates register (creates an alias)
% _        ⊻ %;							\ ( r # -- #-1)

% ><       { >< } %;						\ ( r1 r2 # -- r2 r2 # )
% <<<      { <<< } %;						\ ( r1 r2 r3 # -- r3 r1 r2 # )
% >>>      { >>> } %;						\ ( r1 r2 r3 # -- r2 r3 r1 # )
% >|       1+ { >| ∧ } %;				 	\ ( r1 r2 # -- r1 r2 r1 #+1 )
% >>|      1+ { >>| ∧ } %;				 	\ ( r1 r2 r3 # -- r1 r2 r3 r1 #+1 )
% >|>|     1+ 1+ { >|>| ∧ >< ∧ >< } %;

% >r       1- { >ret } %;
% r>       1+ { ret> } %;


% lit      @skip | opt-lit ! opt-index 1+! .. 1+ { ?∧ } %;	\ ( # -- r #+1 )	Allocates new register
$ lit      green ." mov" tab yellow ." r" | . bs ." , " opt-lit @ .. norm $;

% branch   @skip | opt-branch ! opt-index 1+! .. %;		\ ( -- )
% ?branch  @skip | opt-branch ! opt-index 1+! .. ⊻ %;		\ ( r # -- #-1 )
% -?branch @skip | opt-branch ! opt-index 1+! .. ⊻ %;		\ ( r # -- #-1 )

% (if)     >< { 1- phi-stack dirupload } >< 1+ %;		\			Upload stack as if after ?BRANCH
% (else-pre) tmp-stack diroffload %;
% (else-post) phi-stack download tmp-stack download phi-stack revoffload %;
% (then)   %;
% (begin)  %;
% (until)  %;
% (again)  %;
% (ahead)  %;
% (while)  %;
% (leave)  %;
% (repeat) %;
% (continue) %;
% (break) %;
% (for)    1- { >cyc } phi-stack revupload %;			\ ( r # -- #-1 )	Takes counter off the stack TODO: Save counter on another stack
% I        1+ { cyc> ∧ | >cyc } %;
% (over)   @skip | opt-branch ! opt-index 1+! .. ;% cyc> ∨ ;%;					\ ( -- )

% +        1+ { 						\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
           >< ∨∧ if | <<< >< |∨ >< else				\			Try to allocate rs1 as rd, then rs2, then a new register
	   >< ∨∧ if | else 
	   ?∧ then then
           | >tmp } ;% 1- 1- tmp> >< ;%;			\ ( -- rd #-1 )

\ % -        1+ { |∨ >< |∨ >< ?∧ | >tmp } ;% 1- 1- tmp> >< ;%;	\ ( r1 r2 # -- r3 #-1 )	Frees two registers and allocates one
% -        1+ { 						\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
           >< ∨∧ if | <<< >< |∨ >< else				\			Try to allocate rs1 as rd, then rs2, then a new register
	   >< ∨∧ if | else 
	   ?∧ then then
           | >tmp } ;% 1- 1- tmp> >< ;%;			\ ( -- rd #-1 )

% 1+       %;							\ 			Increment and decrement do not change register allocation
% 1-       %;

% ,        ⊻ %;							\ ( r # -- #-1 )	Frees the parameter
% emit     ⊻ %;							\ ( r # -- #-1 )	Frees the parameter 

								\\ Assembling
								\ TODO: Symmetric operations might favor register with lower index rather then RS1
								\ Is it possible to determine an optimal local strategy?
$ +        >>> >|>| - if <<< >|>| -				\ ( rs1 rs2 rd -- )	Assemble +
           if							\			RD <> RS1, RS2
	   >>> >< green ." mov" tab yellow ." r" | . bs ." , r" >< . norm tab green ." add" tab yellow ." r" . bs ." , r" . bs norm 
           else							\			RD = RS2
           _ green ." add" tab yellow ." r" . bs ." , r" . bs norm
	   then
	   else							\			RD = RS1
           >< _ green ." add" tab yellow ." r" . bs ." , r" . bs norm
	   then $;

$ -        >>> >|>| - if <<< >|>| -
           if							\			RD <> RS1, RS2
	   >>> >< green ." mov" tab yellow ." r" | . bs ." , r" >< . norm tab green ." sub" tab yellow ." r" . bs ." , r" . bs norm 
	   else							\			RD = RS2
	   >< _ green ." sub" tab yellow ." r" | . bs ." , " ." r" >< . bs tab green ." neg " tab yellow ." r" . bs norm
	   then
	   else							\			RD = RS1
	   >< _ green ." sub" tab yellow ." r" . bs ." , " ." r" . bs norm
	   then  $;

$ 1+       green ." inc" tab yellow ." r" . bs norm $;
$ 1-       green ." dec" tab yellow ." r" . bs norm $;

$ (if)     green ." test" tab yellow ." r" | . bs ." , " ." r" | . bs norm $;
$ ?branch  green ." jz " tab opt-branch @ opt-index @ + 1- purple . norm $;
$ -?branch green ." jnz" tab opt-branch @ opt-index @ + 1- purple . norm $;
$ branch   green ." jmp" tab opt-branch @ opt-index @ + 1- purple . norm $;


\ $ (over)   green ." dec" cyc> | >cyc tab yellow ." r" . tab green ." jnz" tab opt-branch @ opt-index @ + 1- purple . norm $;


\ 3 1 2
\ 1 2 3

$ (over)   
           tmp> | >tmp | phi> | >phi 
	   - if
	   fee bad57ac .abort else
           phi-stack download phi-stack dirupload phi-stack diroffload _	\ Make a copy of the register set on the Phi stack      
	   cr %.S
	   phi> | { 1+ 2/ for
	   phi> >|>| 
	   - if
	   green ." mov" tab yellow ." r" . bs ." , r" . norm tab
	   else
	   _ _
	   then 
	   over
	   } 1- 2/ | if for phi-stack s> _ _ over else _ then
	   cr %.S
	   _ phi-stack onload
	   cr %.S
           then
           green ." dec" cyc> | >cyc tab yellow ." r" . tab green ." jnz" tab opt-branch @ opt-index @ + 1- purple . norm $;



$ (then)   $;

								\\ Simpler examples, w/o Phi junctions
: q - + ;
1 2 3 q ..
: qq 1 2 3 q ;
qq ..
cold
:^ ?^ ?^ ?^ 3 ^> q 
#_
:^ 0 ^> qq 
#_
: q >| { + + } + ;
:^ ?^ ?^ ?^ 3 ^> q 
#_
: q >|>| { { + + } } + >< + ;
:^ ?^ ?^ ?^ 3 ^> q 
#_
: q >|>| { { - + } } - >< - ;
:^ ?^ ?^ ?^ 3 ^> q 
#_

cold
: cs-if0 1 >< | if + else - then noop ;
: cs-if1 1 >< | if 11 + else - 55 then + ;
0 cs-if0 .. 
1 cs-if0 .. 
2 cs-if0 .. 
0 cs-if1 .. 
1 cs-if1 .. 
2 cs-if1 .. 
cold
:^ ?^ 1 ^> cs-if0 
#_

cold
:^ ?^ 1 ^> cs-if1 
#_

: cs-for0 0 >< for I + over ;
1 cs-for0 .. 
2 cs-for0 .. 
ff cs-for0 .. 

cold
:^ ?^ 1 ^> cs-for0 
#_

: cs-for1 { 0 1 2 } for I + <<< over + + ;
1 cs-for1 ..
2 cs-for1 ..
3 cs-for1 ..
4 cs-for1 ..
5 cs-for1 ..
ff cs-for1 ..
cr
:^ ?^ 1 ^> cs-for1 
#_
2600d f00d .abort


cold
: fib      | if 0 1 >>> for >| + >< over _ then ;
:^ ?^ 1 ^> fib 
#_  

1f00d 600d .abort

cold
: cs4 3 begin 30 emit 1- | continue 31 emit >< | break 32 emit | 1+ while 33 emit _ 1 1 repeat 34 emit then 35 emit ;
\ : cs5 41 3 begin 30 emit { 1+ ?? } 1- | continue 31 emit { 1+ ?? } 2 pick break 32 emit { 1+ ?? } | while 33 emit { 1+ ?? } repeat 34 emit { 1+ ?? } then _ 35 emit emit _ 36 emit ;
: cs5 41 3 begin 30 emit .S { 1+ } 1- | continue 31 emit .S { 1+ } >>| break 32 emit { 1+ } | 1+ while .S 33 emit _ >< _ 1 >< 2 .S repeat 34 emit { 1+ } then _ 35 emit red emit norm _ 36 emit ;
: cs50 41 3 begin { 1+ } 1- | continue { 1+ } >>| break { 1+ } | 1+ while _ >< _ 1 >< 2 repeat { 1+ } then _ emit _ ;
0 cs4 
1 cs4
cold
0 cs5 .S 
cold
1 cs5 .S 
cold
0 cs50 .S 
cold
1 cs50 .S 
cold
:^ ?^ 1 ^> cs50 #_

								\\ Fibonacci sequence generator
								\ 0, 1, 2, 3, 4, 5, 6,  7,  8,  9
								\ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
								\ n	Fn = Fn-1 + Fn-2
: fib3     | if { 0 1 2 } 1- 1- for >>> >>| >>| + + over <<< _ _ then noop ;
								\ 0, 1, 2, 3, 4,  5,  6,  7
								\ 0, 1, 2, 3, 6, 11, 20, 37

cold

\ 600df00d 0c0de .abort

