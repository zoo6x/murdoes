
\\ Optimizer
\
								\\ Debug output
: ..S .S ;
: .S blue ..S norm ;						\ Blue stack

								\\ Regallocing and assembling states
: (%>)     | INTERPRETING >cfa@ >>> REGALLOCING >< does ;	\ ( xt -- )		Sets word's register allocation semantics to its execution semantics
: %>       ' (%>) ;						\ ( "<name>" -- )	Sets register allocation semantics to execution semantics
: <%       latest (%>) ;					\ ( -- )		Sets latest word's register allocation semantics to execution semantics

: (:)      : ;							\ 			Redefine : to enable REGALLOCING state
: :        (:) <% ;

: ($>)     | INTERPRETING >cfa@ >>> ASSEMBLING >< does ;	\ ( xt -- )		Sets word's register allocation semantics to its execution semantics
: $>       ' ($>) ;						\ ( "<name>" -- )	Sets register allocation semantics to execution semantics
: <$       latest ($>) ;					\ ( -- )		Sets latest word's register allocation semantics to execution semantics

: INTERPRETING! INTERPRETING state! ;

: REGALLOCING! REGALLOCING state! ;
:: REGALLOCING!!  code rstate REGALLOCING mov.i, ret, <% <$	\ ( -- )		Sets state to REGALLOCING without address interpreter involvement

: ASSEMBLING! ASSEMBLING state! ;
:: ASSEMBLING!!  code rstate ASSEMBLING mov.i, ret, <%		\ ( -- )		Sets state to ASSEMBLING without address interpreter involvement

: DEALLOCING! DEALLOCING state! ;
:: DEALLOCING!!  code rstate DEALLOCING mov.i, ret, <%		\ ( -- )		Sets state to DEALLOCING without address interpreter involvement

: regalloc REGALLOCING! execute interpreting! INTERPRETING! ;	\ ( xt -- )		Sets STATE to REGALLOCING for the XT 

: :%       : compile interpreting! ;

								\\ Register allocation
:: #regs   10 val						\ Number of CPU registers
:: regs    adr #regs allot					\ Register alias count
: #r       regs + c@ ;						\ ( r -- #r )		Returns number of references for a register
: ^        regs + | c@ 1+ >< c! ; 				\ ( r -- )		Increments reference count for a register. TODO: Add overflow/underflow checks
: v        regs + | c@ | if 1- >< c!				\ ( r -- )		Decrements reference count for a register
           else a11a501 .abort then ; 
: v^       regs + | c@ | if 1- | if >< c! 0 else _ _ 1 then 	\ ( r -- 1|0 )		If register is not aliased, then it can be reused
           else a11a502 .abort then ; 
								\ 			otherwise decrement reference count and return 0
: ?^       regs #regs for | c@ I >< -leave _ 1+ over		\ ( -- r | ABORT )	Allocates a new register, if one is available
           0add bada110c .abort
           then >< _ #regs >< - | ^ ;
: ∧        | ^ ;						\ ( r -- r )		Increments reference count for a register, leaving register on the stack
: ∨        v ;
: |∨       | v ;						\ ( r -- r )		Decrement reference count for a register, leaving register on the stack
: ∨∧       | v^ ;						\ ( r -- r 1|0 )	Free register and reallocate it, if it's not aliased
: ?∧       ?^ ;
: ⊻        1- { ∨ } ;						\ ( r # -- #-1 )	Frees a register
: &^       | #r 1- if _ ?^ then ;				\ ( r -- r|r` )         Returns the same register if it has exactly one reference, or a new one
: &∧       &^ ;

: .regs    regs #regs for | c@ .. 1+ over _ ;

								\\ Stacks for control structures
: dirupload >< | { | | if for | { I - 1+ #| >| >s } over _	\ ( an ... a1 n s -- a1 ... an n )  Copy N elements from data stack onto the specified stack
            else _ _ then } | <<< >< >s  ;
: revupload >< | { | if for | I 1+ #| >< >s over		\ ( an ... a1 n s -- an ... a1 n )  Copy N elements from data stack onto the specified stack
            else _ then } | <<< >< >s  ;

: offload   | if for ∨ over else _ then ;
: diroffload dirupload offload ;				\ ( an ... a1 n s -- an ... a1 n )  Push N elements from data stack onto the specified stack
: revoffload revupload offload ;

: download | s> | { | if for | s> ∧ >< over _ else _ _ then } ; \ ( s -- a1 ... an n ) (s: a1 ... an n -- ) Pop N elements off the specified stack onto the data stack
: onload  | s> | { | if for | s> >< over _ else _ _ then } ;	\ ( s -- a1 ... an n ) (s: a1 ... an n -- ) Pop N elements w/o changing references

:: tmp-stack 100 stack						\ Temporary stack, for transfers between other stacks
: >tmp    tmp-stack >s ;
: tmp>    tmp-stack s> ;

:: ret-stack 100 stack						\ Return stack
: >ret    ret-stack >s ;
: ret>    ret-stack s> ;

:: cyc-stack 100 stack						\ Cycle stack
: >cyc    cyc-stack >s ;
: cyc>    cyc-stack s> ;

:: phi-stack 100 stack						\ Phi junction stack
: >phi    phi-stack >s ;
: phi>    phi-stack s> ;

:: opt-index        0 var					\ Index inside current word, for branch visualization
:: opt-lit          0 var					\ Holds 1-cell literal, offset or other data between regallocing and assembling
:: opt-xt           0 var					\ Holds XT of the currently executing REGALLOCING/ASEMBLING word
:: opt-branch       0 var					\ Holds latest branch offset
:: opt-phi-move     0 var					\ Flag indicating whether φ requires moving regiters
:: opt-phi-temp-reg 0 var					\ Temporary register for φ moves
:: opt-phi-save-reg 0 var					\ Saved register for φ moves
:: opt-phi-dest-reg 0 var					\ Register to be assigned from the saved register
:: opt-phi-forward  0 var					\ Flag indicating whether the φ-junction is forward or backward

: %.debug 							\ ( xt -- )		Debug print word name and stack
           cr
	   opt-index @ purple . norm
           1b emit 5b emit 30 emit 34 emit 47 emit
           >name count white type norm

           1b emit 5b emit 31 emit 33 emit 47 emit ;
: %.S      
           1b emit 5b emit 31 emit 39 emit 47 emit
           ..S
           1b emit 5b emit 33 emit 39 emit 47 emit
	   .regs 
           1b emit 5b emit 37 emit 32 emit 47 emit
	   52 emit 3a emit bl emit ret-stack .stack
           1b emit 5b emit 37 emit 39 emit 47 emit
	   43 emit 3a emit bl emit cyc-stack .stack
           1b emit 5b emit 38 emit 38 emit 47 emit
	   cf emit 86 emit 3a emit bl emit phi-stack .stack
           1b emit 5b emit 31 emit 30 emit 39 emit 47 emit
	   54 emit 3a emit bl emit tmp-stack .stack
           1b emit 5b emit 31 emit 32 emit 38 emit 47 emit
           ." | "
           1b emit 5b emit 31 emit 33 emit 30 emit 47 emit
	   ;

								\\ Regallocing semantics definitions
: noop ;

: $        here (exec) ASSEMBLING ' | >r does r> _		\ ( "<name>" --  )	Creates new semantics for assembling state
           compile interpreting!
	   ] ;
: $;       compile ASSEMBLING!! compile exit [compile] [ ; immediate

$ noop     $;

' exit INTERPRETING >cfa@ REGALLOCING ' exit does
' exit INTERPRETING >cfa@ ASSEMBLING ' exit does
' exit INTERPRETING >cfa@ DEALLOCING ' exit does

' interpreting! INTERPRETING >cfa@ REGALLOCING ' interpreting! does
' interpreting! INTERPRETING >cfa@ ASSEMBLING ' interpreting! does
' interpreting! INTERPRETING >cfa@ DEALLOCING ' interpreting! does

: assm     ;
$ assm     $;

: %        here (exec) REGALLOCING ' | >r does 			\ ( "<name>" --  )	Creates new semantics for register allocation state,
           ['] assm ASSEMBLING   >cfa@ ASSEMBLING r> | >r does
           ['] assm INTERPRETING >cfa@ DEALLOCING r> | >r does r>
           compile interpreting! 				\			which equals to execution semantics of its constituents
	   | opt-xt !
	   [compile] literal
	   compile %.debug					\ DEBUG
           ] ;

: %;       compile %.S						\ DEBUG

           compile ASSEMBLING!!
           opt-xt @
	   compile,
	   compile interpreting!
           
           compile DEALLOCING!!
           opt-xt @
	   compile,
	   compile interpreting!

	   compile opt-index
	   compile 1+!

	   compile REGALLOCING!!

	   compile exit [compile] [ ; immediate

: ;%								\			Finish REGALLOCING definition and start DEALLOCING definition
           [compile] %;
           here (exec) DEALLOCING opt-xt @ does
	   compile interpreting!
	   ] ; immediate
	  
: ;%;      	  
	   compile REGALLOCING!!

	   compile exit [compile] [ ; immediate

% noop %;
	   							\\ Register allocation primitives
: regs-init							\ ( -- )		Initializes array of referenced registers
           regs #regs 0 fill
	   tmp-stack empty
	   ret-stack empty
	   cyc-stack empty
	   phi-stack empty
           rsp ∧ _						\ 			RSP should not be used as a general-purpose register
;
								\\ Syntactic sugar
: :^       regs-init ;
: ^>
	   0 opt-index !
           cr %.S
	   ' regalloc 
	   ['] exit %.debug %.S ;

								\\ Register allocation
% |        norm 1+ { | ∧ } %;					\ ( r # -- r r #+1 )	Duplicates register (creates an alias)
% _        ⊻ %;							\ ( r # -- #-1)

% ><       { >< } %;						\ ( r1 r2 # -- r2 r2 # )
% <<<      { <<< } %;						\ ( r1 r2 r3 # -- r3 r1 r2 # )
% >>>      { >>> } %;						\ ( r1 r2 r3 # -- r2 r3 r1 # )
% >|       1+ { >| ∧ } %;				 	\ ( r1 r2 # -- r1 r2 r1 #+1 )
% >>|      1+ { >>| ∧ } %;				 	\ ( r1 r2 r3 # -- r1 r2 r3 r1 #+1 )
% >|>|     1+ 1+ { >|>| ∧ >< ∧ >< } %;

% >r       1- { >ret } %;
% r>       1+ { ret> } %;


% lit      @skip | opt-lit ! opt-index 1+! .. 1+ { ?∧ } %;	\ ( # -- r #+1 )	Allocates new register

% branch   @skip | opt-branch ! opt-index 1+! .. %;		\ ( -- )
% ?branch  @skip | opt-branch ! opt-index 1+! .. ⊻ %;		\ ( r # -- #-1 )
% -?branch @skip | opt-branch ! opt-index 1+! .. ⊻ %;		\ ( r # -- #-1 )

% (if)     >< { 1- phi-stack revupload } >< 1+ %;		\			Upload stack as if after ?BRANCH
% (else-pre)
           tmp-stack diroffload %;
% (else-post) 
           phi-stack download
	   phi-stack revoffload
	   phi-stack download
	   tmp-stack download
	   phi-stack revoffload %;
% (then)   %;
% (begin)  phi-stack revupload %;				\			Upload stack as it is now
% (until)  %;
% (again)  %;
% (ahead)  %;
% (while)  >< { 1- phi-stack revupload } >< 1+ %;		\			Upload stack as if after ?BRANCH
% (-leave) >< { 1- 
           tmp-stack revupload 
	   phi-stack onload
	   tmp-stack onload 
	   phi-stack revupload #_
	   phi-stack revupload #_ } >< 1+
           @skip | opt-branch ! opt-index 1+! .. ⊻ %;
% (repeat-pre)
           phi-stack download
	   tmp-stack revoffload %;
% (repeat-post)
           offload
	   tmp-stack download %;
% (continue) %;
% (break)  %;
% (for)    1- { | &∧ | >cyc }					\ ( r # -- #-1 )	Takes counter off the stack TODO: Save counter on another stack
           <<< { { phi-stack revupload } } >>> ;%
           { _ _ } ;%; 
% I        1+ { cyc> ∧ | >cyc } %;
% (over)   @skip | opt-branch ! opt-index 1+! .. ;%
           { cyc> ∨ } ;%;
% (over-post) %;

% +        { 							\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
           >< ∨∧ if | <<< >< |∨ >< else				\			Try to allocate rs1 as rd, then rs2, then a new register
	   >< ∨∧ if | else 
	   ?∧ then then
           } 1+ cr ;%
	   { { _ _ } } 1- 1- ;%;			\ ( -- rd #-1 )

% -        { 							\ ( rs1 rs2 # -- rs1 rs2 rd #+1 )
           >< ∨∧ if | <<< >< |∨ >< else				\			Try to allocate rs1 as rd, then rs2, then a new register
	   >< ∨∧ if | else 
	   ?∧ then then
           } 1+ ;%
	   { { _ _ } } 1- 1- ;%;			\ ( -- rd #-1 )

% 1+       %;							\ 			Increment and decrement do not change register allocation
% 1-       %;

								\\ Stubs to ignore debug output words in the optimizer for now
% ,        ⊻ %;							\ ( r # -- #-1 )	Frees the parameter
% emit     ;% ⊻ ;%;							\ ( r # -- #-1 )	Frees the parameter 

% cr %;
% ??       %;							\ ( r # -- #-1 )	Frees the parameter
% ..       ⊻ %;							\ ( r # -- #-1 )	Frees the parameter
% .        ⊻ %;							\ ( r # -- #-1 )	Frees the parameter
% .S %;
% yellow   %;
% norm     %;


								\\ Assembling
								
								\ CAUTION! Assembling words should leave the stack as it was passed, do not add or drop items!
								\          Deallocing semantics should set up the stack properly, if needed

								\ TODO: Symmetric operations might favor register with lower index rather then RS1
								\ Is it possible to determine an optimal local strategy?

$ +        { >>> >|>| - if <<< >|>| -				\ ( rs1 rs2 rd )	Assemble +
           if							\			RD <> RS1, RS2		mov rd, rs1	add rd, rs1
	   { >|>| } | { <<< } >>> >< green ." mov" tab yellow ." r" | . bs ." , r" >< . norm cr %.S green ." add" tab yellow ." r" . bs ." , r" . bs norm 
           else							\			RD = RS2
           <<< >|>| green ." add" tab yellow ." r" . bs ." , r" . bs norm
	   then
	   else							\			RD = RS1
           <<< >|>| green ." add" tab yellow ." r" . bs ." , r" . bs norm
	   then } cr %.S $;

$ -        { >>> >|>| - if <<< >|>| -				\ ( rs1 rs2 rd )	Assemble -
           if							\			RD <> RS1, RS2		mov rd, rs1	sub rd, rs1
	   { >|>| } | { <<< } >>> >< green ." mov" tab yellow ." r" | . bs ." , r" >< . norm cr %.S green ." sub" tab yellow ." r" . bs ." , r" . bs norm 
	   else							\			RD = RS2
	   >< _ green ." sub" tab yellow ." r" | . bs ." , " ." r" >< . bs cr %.S green ." neg " tab yellow ." r" . bs norm
	   then
	   else							\			RD = RS1
	   <<< >|>| green ." sub" tab yellow ." r" . bs ." , " ." r" . bs norm
	   then } cr %.S $;

$ 1+       { green ." inc" tab yellow ." r" | . bs norm } $;
$ 1-       { green ." dec" tab yellow ." r" | . bs norm } $;

$ lit      { green ." mov" tab yellow ." r" | . bs ." , " opt-lit @ .. norm } $;
$ emit     { green ." emit" tab yellow ." r" | . bs norm } $;

\ φ-junction

: φ
           1 opt-phi-move !
	   -1 opt-phi-save-reg !
	   -1 opt-phi-temp-reg !
	   -1 opt-phi-dest-reg !
           | phi> | >phi
	   - if
		   fee bad57ac .abort
	   else
		   phi-stack download
		   phi-stack dirupload
		   phi-stack diroffload
		   tmp-stack dirupload
		   _
		   phi> | if for
			   phi> >|>|
			   - if
				   opt-phi-move @ if
					   0 opt-phi-move !
					   ?∧ opt-phi-temp-reg !
					   green ." mov!" tab yellow ." r" opt-phi-temp-reg @ . bs ." , r" | . norm cr %.S
					   | opt-phi-save-reg !
					   green ." mov@" tab yellow ." r" . bs ." , r" . norm cr %.S
				   else
					   >| opt-phi-save-reg @ - if
						   green ." mov" tab yellow ." r" . bs ." , r" . norm cr %.S
					   else
						   | opt-phi-dest-reg !
						   _ _
					   then
				   then
			   else
				   _ _
			   then
		   over else _ then
		   opt-phi-dest-reg @ 1+ if
			   green ." mov#" tab yellow ." r" opt-phi-dest-reg @ . bs ." , r" opt-phi-temp-reg @ . norm cr %.S
		   then
		   opt-phi-move @ if else opt-phi-temp-reg @ ∨ then
		   opt-phi-forward @ if tmp-stack onload offload else tmp-stack onload then
		   phi-stack onload
		   opt-phi-forward @ if phi-stack revupload #_ phi-stack download else #_ then
		   \ _
           then 
	   ;

: <φ       0 opt-phi-forward ! φ ;
: >φ       1 opt-phi-forward ! φ ;

$ (if)     { green ." test" tab yellow ." r" | . bs ." , " ." r" | . bs norm } $;
$ ?branch  { green ." jz " tab opt-branch @ opt-index @ + purple . norm } $;
$ -?branch { green ." jnz" tab opt-branch @ opt-index @ + purple . norm } $;
$ branch   { green ." jmp" tab opt-branch @ opt-index @ + purple . norm } $;

$ (for)    { >|>| - if
           >|>| green ." mov" tab yellow ." r" . bs ." , r" . norm
           then } $;
$ (over)
           { green ." dec" cyc> | >cyc tab yellow ." r" . norm cr %.S green ." jz" tab opt-index @ 1+ purple . norm cr %.S }
           <φ
           { cr %.S green ." jmp" tab opt-branch @ opt-index @ + 1+ purple . norm } cr %.S $;

$ (while)  { green ." test" tab yellow ." r" | . bs ." , " ." r" | . bs norm } $;

$ (then)   >φ $;
$ (again)  <φ $;
$ (repeat-pre) <φ $;
$ (repeat-post) $;


								\\ Simpler examples, w/o Phi junctions
: q - + ;
1 2 3 q ..
: qq 1 2 3 q ;
qq ..
cold
:^ ?^ ?^ ?^ 3 ^> q 
#_
:^ 0 ^> qq 
#_
: q >| { + + } + ;
:^ ?^ ?^ ?^ 3 ^> q 
#_
: q >|>| { { + + } } + >< + ;
:^ ?^ ?^ ?^ 3 ^> q 
#_
: q >|>| { { - + } } - >< - ;
:^ ?^ ?^ ?^ 3 ^> q 
#_

: cs-for0 0 >< for I + over ;
1 cs-for0 .. 
2 cs-for0 .. 
ff cs-for0 .. 

cold
:^ ?^ 1 ^> cs-for0 
#_

: cs-for00 for over ;
1 cs-for00 .S 
2 cs-for00 .S 

cold
:^ ?^ 1 ^> cs-for00
#_

: cs-for1 for I ?? | 1- 1- -leave yellow . norm over 2a emit | then 2b emit _ ;
1 cs-for1 .S 
2 cs-for1 .S 
3 cs-for1 .S 
4 cs-for1 .S 

see cs-for1
cold
:^ ?^ 1 ^> cs-for1 
#_

\ 4444 c0de .abort

: cs-for2 cr | for I >< | for >| I + .. over >< _ cr over _ ;
1 cs-for2 cr 
2 cs-for2 cr 
3 cs-for2 cr 
4 cs-for2 cr 

cold
:^ ?^ 1 ^> cs-for2 
#_

cold
: cs-if0 1 >< | if + else - then noop ;
: cs-if1 1 >< | if 11 + else - 55 then + ;
: cs-if2 1 >< | if >< then noop - ;
0 cs-if0 .. 
1 cs-if0 .. 
2 cs-if0 .. 
0 cs-if1 .. 
1 cs-if1 .. 
2 cs-if1 .. 
0 cs-if2 .. 
1 cs-if2 .. 
2 cs-if2 .. 
cold
:^ ?^ 1 ^> cs-if2 
cold
:^ ?^ 1 ^> cs-if0 
#_

cold
:^ ?^ 1 ^> cs-if1 
#_

: cs-if3 2 >< | | if 1 >< - then - - ;
cold 0 cs-if3 .S 
cold 1 cs-if3 .S 
cold 2 cs-if3 .S 
cold 3 cs-if3 .S 
cold
:^ ?^ 1 ^> cs-if3 
#_
.( φ *** FALSE branch has two copies of a value [ 1 0 0 ], while TRUE branch produces different values [ 1 0 2 ]. How to merge these?  )

: cs-for1 { 0 1 2 } for I + <<< over - + ;
1 cs-for1 ..
2 cs-for1 ..
3 cs-for1 ..
4 cs-for1 ..
5 cs-for1 ..
ff cs-for1 ..
cr
:^ ?^ 1 ^> cs-for1 
#_


cold
: fib      | if 0 1 >>> for >| + >< over _ then ;
cold
0 fib ..  
1 fib ..  
2 fib ..  
3 fib ..  
4 fib ..  
5 fib ..  
6 fib ..  
7 fib ..  
8 fib ..  
9 fib ..  

see fib

cold
:^ ?^ 1 ^> fib 
#_  
.( φ *** Temporary register should be allocated only if swap is to be performed. How to detect it? )

cold
: cs-if3 { 11 22 33 } if <<< then - + noop ;
0 cs-if3 ..
1 cs-if3 ..
:^ ?^ 1 ^> cs-if3
#_

: <<<< \ a b c d -- d a b c
  >< >r <<< r> ;
cold 11 22 33 44 <<<< .S
: cs-if4 { 11 22 33 44 } if <<<< then - + - noop ;
0 cs-if4 ..
1 cs-if4 ..
cold
:^ ?^ 1 ^> cs-if4
#_

: fib3     | if { 0 1 2 } for >>> >>| >>| + + over <<< _ _ then noop ;
cold
0 fib3 ..  
1 fib3 ..  
2 fib3 ..  
3 fib3 ..  
4 fib3 ..  
5 fib3 ..  
6 fib3 ..  
7 fib3 ..  
8 fib3 ..  
9 fib3 ..  

cold
:^ ?^ 1 ^> fib3

.(  φ Fib3 WORKS!!! Well, mov r0, r0... But this is another problem. Let's look for more serious ones first )

: cs-1 1 2 begin >< again ;
cold
:^ 0 ^> cs-1 


: cs-2 { 11 33 } begin 1- | while { >< } repeat _ - ;
1 cs-2 .. 
2 cs-2 .. 
3 cs-2 .. 
4 cs-2 .. 
cold
:^ ?^ 1 ^> cs-2  

c0de 42 .abort

cold
: cs4 3 begin 30 emit 1- | continue 31 emit >< | break 32 emit | 1+ while 33 emit _ 1 1 repeat 34 emit then 35 emit ;
\ : cs5 41 3 begin 30 emit { 1+ ?? } 1- | continue 31 emit { 1+ ?? } 2 pick break 32 emit { 1+ ?? } | while 33 emit { 1+ ?? } repeat 34 emit { 1+ ?? } then _ 35 emit emit _ 36 emit ;
: cs5 41 3 begin 30 emit { 1+ } 1- | continue 31 emit { 1+ } >>| break 32 emit { 1+ } | 1+ while 33 emit _ >< _ 1 >< 2 repeat 34 emit { 1+ } then _ 35 emit red emit norm _ 36 emit ;
: cs50 41 3 begin { 1+ } 1- | continue { 1+ } >>| break { 1+ } | 1+ while _ >< _ 1 >< 2 repeat { 1+ } then _ emit _ ;
0 cs4 
1 cs4
cold
0 cs5 .S 
cold
1 cs5 .S 
cold
0 cs50 .S 
cold
1 cs50 .S 
cold
:^ ?^ 1 ^> cs50 #_


600df00d 0c0de .abort

