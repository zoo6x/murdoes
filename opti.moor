\
\\ Optimizer
\

\\ References
\ https://github.com/tarantool/tarantool/wiki/LuaJIT-Optimizations
\ https://medium.com/@AlexanderObregon/everything-you-need-to-know-about-register-allocation-in-c-27019602cc5c
\ https://langdev.stackexchange.com/questions/1441/what-are-the-disadvantages-of-using-ssa-form
\ https://en.wikipedia.org/wiki/Register_allocation

\\ Concepts

\\ Virtual registers
\ - Reference a CPU register or a (local?) memory slot
\ - Optimizer can change virtual reference without re-emitting SSA IR 
\   (for instance, if hint or statistics indicate that this exact VR shold be stored in register/memory)

\\ Stack changes
\ In IR generation (?) state each word returns
\ - Number of values taken of the stack
\ - Number of values put onto the stack
\ - Aliasing between new and old values, if any
\ ( -- [ new old ]... naliases nput ntaken)
\ This is needed only for code words, for Forth words everything is deduced from threaded code
\ - Words are
\   - inline: registers are allocated dynamically
\   - leaf: do not call other words (but may inline others)
\   - twig: non-leaf nodes, call other words that are already compiled


:: INTERPRETING  0 val
:: COMPILING    -2 val
:: DECOMPILING  -4 val
:: REGALLOCING  -6 val

: >cfa     cells + cell - cell - ;				\ ( xt state -- cfa )	Returns CFA for given state for XT
: cfa@     | @ >< cell + @ >< ;					\ ( cfa -- param code )		Returns param and code for CFA

: %        here (exec) REGALLOCING ' does ] ;			\ ( "<name>" --  )	Creates new semantics for register allocation state
: (%>)     | INTERPRETING >cfa cfa@ >>> REGALLOCING >< does ;	\ ( xt -- )		Sets word's register allocation semantics to its execution semantics
: %>       ' (%>) ;						\ ( "<name>" -- )	Sets register allocation semantics to execution semantics
: <%       latest (%>) ;					\ ( -- )		Sets latest word's register allocation semantics to execution semantics

: REGALLOCING! REGALLOCING state! ;
: INTERPRETING! INTERPRETING state! ;
: REGALLOCING!! REGALLOCING state!! ;

: regalloc REGALLOCING! ' execute interpreting! INTERPRETING! ;	\ ( -- )		Sets STATE to REGALLOCING for the next text interpreter word 
								\			This allies to stack manipulation words without effects
: :%       : compile interpreting! ;
: %;       compile REGALLOCING!! compile exit [compile] [ ; immediate

:: vreg    0 var 						\ ( -- a-vr )		Variable holding latest allocated virtual register (VR)
:% ^       vreg @ | 1+ vreg ! %;				\ ( -- vr ) 		Returns current VR and increases next VR value
: :^       0 vreg ! ;
: ^>       regalloc ;

:: skip    code rtmp pop, rpc pop, 				\ ( -- )		Skip next adress interpreter word
		rpc inc, rpc inc, rpc inc, rpc inc,
		rpc inc, rpc inc, rpc inc, rpc inc,
		rpc push, rtmp push, ret, <% 

% |        ;							\ ( r -- r r )		Duplicates register (creates an alias)
% _        ;							\ ( r -- )		Frees a register

% ><       ;							\ ( r1 r2 -- r2 r2 )	Swaps registers

% lit      skip ^ ;						\ ( -- r )		Allocates new register
% emit     _ ;							\ ( r -- )		Frees a register

% +        _ _ ^ ;						\ ( r1 r2 -- r3 )	Frees two registers and allocates one
% ,        _ ;							\ ( r -- )		Frees a register

\ 0, 1, 2, 3, 4, 5, 6,  7,  8,  9
\ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
: fib \ n	Fn = Fn-1 + Fn-2
  0 1 >>> for >| + >< over _ ;

\ https://www.forwardcom.info/

\						#r count
\ see fib					0 1					rax
\ 425d58 411240 lit	0 			0 1 2					mov	rcx, 0
\ 425d68 411240 lit	1			0 1 2 3					mov	rdx, 1
\ 425d78 41bde0 >>>				1 2 0 3
\ 425d80 4221b0 (for)			        1 2 2		R: 0
\     88        <mark				1 2 2		R: 0	S: 2 2 1 
\ 425d88 41bb60 >|           <---------\        1 2 1 3		R: 0			88:
\ 425d90 41ab20 +                      |	1 2 2		R: 0			add	rdx, rcx
\ 425d98 41ba30 ><                     |	2 1 2		R: 0
\ 425da0 4222e0 (over)                 |	2 1 0 3		R: 0			dec	rax
\											jz	:c0
\ 425da8 4117a0 -?branch	425d88-/        2 1 2		R: 0			xchg	rdx, rcx
\		<resolve								jmp     :88		
\ 425dc0 41b7d0 _				2 1
\ 425dc8 410790 exit									rdx

\ 1 => 2, 2 => 1 == 1 => 3, 2 => 1, 3 => 2







