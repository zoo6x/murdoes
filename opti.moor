\
\\ Optimizer
\

								\\ Regallocing state
: %        here (exec) REGALLOCING ' does			\ ( "<name>" --  )	Creates new semantics for register allocation state,
           compile interpreting! ] ;				\			which equals to execution semantics of its constituents
: (%>)     | INTERPRETING >cfa@ >>> REGALLOCING >< does ;	\ ( xt -- )		Sets word's register allocation semantics to its execution semantics
: %>       ' (%>) ;						\ ( "<name>" -- )	Sets register allocation semantics to execution semantics
: <%       latest (%>) ;					\ ( -- )		Sets latest word's register allocation semantics to execution semantics

: REGALLOCING! REGALLOCING state! ;
: INTERPRETING! INTERPRETING state! ;
:: REGALLOCING!!  code rstate REGALLOCING mov.i, ret, <%	\ ( -- )		Sets state to REGALLOCING without address interpreter involvement

: regalloc REGALLOCING! ' execute interpreting! INTERPRETING! ;	\ ( -- )		Sets STATE to REGALLOCING for the next text interpreter word 

: :%       : compile interpreting! ;
: %;       compile REGALLOCING!! compile exit [compile] [ ; immediate

								\\ Register allocation
:: #regs   10 val						\ Number of CPU registers
:: regs    adr #regs allot					\ Register alias count
: ^        regs + | c@ 1+ >< c! ; 				\ ( r -- )		Increments reference count for a register. TODO: Add overflow/underflow checks
: v        regs + | c@ 1- >< c! ; 				\ ( r -- )		Decrements reference count for a register
: ?^       regs #regs for | c@ leave 1+ over bada110c 0 .abort  \ ( -- r | ABORT )	Allocates a new register, if one is available
           then _ #regs I - | ^ ;
: ∧        ^ ;							\			An attempt at aesthetics with Unicode symbols
: ∨        v ;
: ?∧       ?^ ;
: ⊻        1- >r ∨ r> ;						\ ( r # -- #-1 )	Frees a register

: regs-init							\ ( -- )		Initializes array of referenced registers
          regs #regs 0 fill
          rsp ∧							\ 			RSP should not be used as a general-purpose register
;

: :^       regs-init ;
: ^>       regalloc ;

% |        norm 1+ >r | | ∧ r> .S %;				\ ( r # -- r r #+1 )	Duplicates register (creates an alias)
% _        ⊻ .S %;						\ ( r # -- #-1)

% ><       >r >< r> .S %;					\ ( r1 r2 # -- r2 r2 # )
% <<<      >r <<< r> .S %;					\ ( r1 r2 r3 # -- r3 r1 r2 # )
% >>>      >r >>> r> .S %;					\ ( r1 r2 r3 # -- r2 r3 r1 # )

% lit      skip 1+ ?∧ >< .S %;					\ ( # -- r #+1 )	Allocates new register
% ?branch  skip ⊻ .S %;						\ ( r # -- #-1 )		Branches do not allocate registers. MARK and RESOLVE do all work

% +        1- >r ∨ ∨ ?∧ r> .S %;				\ ( r1 r2 # -- r3 #-1 )	Frees two registers and allocates one


% ,        ∨ .S %;						\ ( r # -- #-1 )	Frees the parameter
% emit     ∨ .S %;						\ ( r # -- #-1 )	Frees the parameter 

\\ Fibonacci sequence generator
\ 0, 1, 2, 3, 4, 5, 6,  7,  8,  9
\ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
: fib \ n	Fn = Fn-1 + Fn-2
  | if 0 1 >>> for >| + >< over _ then ;
see fib
cold								\ 			Clear stack. We'll deal with junk later
\					0	1						
\ 424d30  |				0 0	2						
\ 424d38  ?branch	424db8		0	1						
\         (>mark)			0	1		S: 1	0			
\ 424d48  lit	0			0 1	2		S: 1	0			
\ 424d58  lit	1			0 1 2	3		S: 1	0			
\ 424d68  >>>				1 2 0	3		S: 1	0			
\ 424d70  (for)				1 2	2	R: 0	S: 1	0			
\         (<mark)			1 2	2	R: 0	S: 2	2 1	1	0	
\ 424d78: >|				1 2 1	3	R: 0	S: 2	2 1	1	0	
\ 424d80  +				1 2	2	R: 0	S: 2	2 1	1	0	
\ 424d88  ><				2 1	2	R: 0	S: 2	2 1	1	0	
\ 424d90  (over)	424d78		2 1	2		S: 2	2 1	1	0	
\         (<resolve)			2 1	2		S: 1	0			
\ 424da0  _				2	1		S: 1	0			
\ 424da8  branch	424dd0		2	1		S: 1	0			
\         (>resolve)			2	1						
\ 424dd0: exit				2	1						
:^ ?^ 1 
cr .S ^> fib







