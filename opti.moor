\
\\ Optimizer
\

								\\ Regallocing state
: %.debug  >name count white type norm				\ ( xt -- )		Debug print word name and stack
           9 | emit emit ;

: %        here (exec) REGALLOCING ' | >r does r>		\ ( "<name>" --  )	Creates new semantics for register allocation state,
           compile interpreting! 				\			which equals to execution semantics of its constituents
	   [compile] literal compile %.debug
           ] ;
	   							\\ TODO: Do we need these at all?
: (%>)     | INTERPRETING >cfa@ >>> REGALLOCING >< does ;	\ ( xt -- )		Sets word's register allocation semantics to its execution semantics
: %>       ' (%>) ;						\ ( "<name>" -- )	Sets register allocation semantics to execution semantics
: <%       latest (%>) ;					\ ( -- )		Sets latest word's register allocation semantics to execution semantics

: REGALLOCING! REGALLOCING state! ;
: INTERPRETING! INTERPRETING state! ;
:: REGALLOCING!!  code rstate REGALLOCING mov.i, ret, <%	\ ( -- )		Sets state to REGALLOCING without address interpreter involvement

: regalloc REGALLOCING! ' execute interpreting! INTERPRETING! ;	\ ( -- )		Sets STATE to REGALLOCING for the next text interpreter word 

: :%       : compile interpreting! ;
: %;       compile .S 
           compile REGALLOCING!! compile exit [compile] [ ; immediate

								\\ Register allocation
:: #regs   10 val						\ Number of CPU registers
:: regs    adr #regs allot					\ Register alias count
: ^        regs + | c@ 1+ >< c! ; 				\ ( r -- )		Increments reference count for a register. TODO: Add overflow/underflow checks
: v        regs + | c@ 1- >< c! ; 				\ ( r -- )		Decrements reference count for a register
: ?^       regs #regs for | c@ leave 1+ over bada110c 0 .abort  \ ( -- r | ABORT )	Allocates a new register, if one is available
           then _ #regs I - | ^ ;

	   							\\ Register allocation primitives
: ∧        | ^ ;						\ ( r -- r )		Increments reference count for a register, leaving it on the stack
: ∨        v ;
: ?∧       ?^ ;
: ⊻        1- >r ∨ r> ;						\ ( r # -- #-1 )	Frees a register

: regs-init							\ ( -- )		Initializes array of referenced registers
           regs #regs 0 fill
           rsp ∧ _						\ 			RSP should not be used as a general-purpose register
;
								\\ Syntactic sugar
: :^       regs-init ;
: ^>       regalloc ;
: {        compile >r ;	immediate
: }        compile r> ;	immediate

								\\ Register allocation implementation
% |        norm 1+ { | ∧ } %;					\ ( r # -- r r #+1 )	Duplicates register (creates an alias)
% _        ⊻ %;							\ ( r # -- #-1)

% ><       { >< } %;						\ ( r1 r2 # -- r2 r2 # )
% <<<      { <<< } %;						\ ( r1 r2 r3 # -- r3 r1 r2 # )
% >>>      { >>> } %;						\ ( r1 r2 r3 # -- r2 r3 r1 # )
% >|       1+ { >| ∧ } %;				 	\ ( r1 r2 # -- r1 r2 r1 #+1 )

% lit      skip 1+ ?∧ >< %;					\ ( # -- r #+1 )	Allocates new register
% ?branch  skip ⊻ %;						\ ( r # -- #-1 )	Branches do not allocate registers. MARK and RESOLVE do all work
% (for)    1- { ∧ _ } %;					\ ( r # -- #-1 )	Takes counter off the stack TODO: Save counter on another stack
% (over)   skip %;						\ ( -- )		TODO: Do nothing so far. (RESOLVE) will do all the job

% +        1- { ∨ ∨ ?∧ } %;					\ ( r1 r2 # -- r3 #-1 )	Frees two registers and allocates one


% ,        ∨ %;							\ ( r # -- #-1 )	Frees the parameter
% emit     ∨ %;							\ ( r # -- #-1 )	Frees the parameter 

\\ Fibonacci sequence generator
\ 0, 1, 2, 3, 4, 5, 6,  7,  8,  9
\ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
: fib \ n	Fn = Fn-1 + Fn-2
  | if 0 1 >>> for >| + >< over _ then ;
see fib
\					0	1						
\ 424d30  |				0 0	2						
\ 424d38  ?branch	424db8		0	1						
\         (>mark)			0	1		S: 1	0			
\ 424d48  lit	0			0 1	2		S: 1	0			
\ 424d58  lit	1			0 1 2	3		S: 1	0			
\ 424d68  >>>				1 2 0	3		S: 1	0			
\ 424d70  (for)				1 2	2	R: 0	S: 1	0			
\         (<mark)			1 2	2	R: 0	S: 2	2 1	1	0	
\ 424d78: >|				1 2 1	3	R: 0	S: 2	2 1	1	0	
\ 424d80  +				1 2	2	R: 0	S: 2	2 1	1	0	
\ 424d88  ><				2 1	2	R: 0	S: 2	2 1	1	0	
\ 424d90  (over)	424d78		2 1	2		S: 2	2 1	1	0	
\         (<resolve)			2 1	2		S: 1	0			
\ 424da0  _				2	1		S: 1	0			
\ 424da8  branch	424dd0		2	1		S: 1	0			
\         (>resolve)			2	1						
\ 424dd0: exit				2	1						
: q + + ;
cold
:^ ?^ ?^ ?^ 3 ^> q
cold
:^ ?^ 1 ^> fib
\ 600df00d 0 .abort

