: \ 0 word drop ;
\
\ Moore Forth System
\

								\ Comments and debug output
: norm	1b emit 5b emit 30 emit 6d emit ;
: blue	1b emit 5b emit 33 emit 34 emit 6d emit ;
: .\ 0 word count blue type norm 0a emit ;
: cr 0a emit ;
: .. blue . norm ;

: ` c, ;
								\ Register assignment. Should be changed if register aliases are changed
: r0 01 ;							\ rcx = rtop
: r1 02 ;							\ rdx = rtmp
: r2 00 ;							\ rax = rwork
: #0 0 ;							\ Offset of the first available stack item
: #1 8 ;							\ Offset of the second stack item
: #2 10 ;							\ Offset of the third stack item

: rex,     48 ` ;
: rex1,    49 ` ;

: ret,     c3 ` ;						\ ( -- )		ret

:: 1+      code rex, ff ` c1 ` ret,				\ ( n -- n+1)		inc	r0
:: 1-      code rex, ff ` c9 ` ret,				\ ( n -- n-1)		dec	r0

: shl1,    rex, c1 ` e2 ` ` ;					\ ( n -- )		shl	r0, n
:: shl1#3  code	3 shl1,	ret,					\ ( -- )		shl	r1, 3

: off,     rex, ff ` c5 ` ;					\ ( -- )		inc	rstack
: on,      rex, ff ` cd ` ;					\ ( -- )		dec	rstack
:: off     code off, ret,					\ ( a b -- b )

: (load,   rex1, 8b ` ;
: (store,  rex1, 89 ` ;
: load),   ef ` ` ;
: store),  ef ` ` ;
: load1,   (load, 54 ` #1 load), ;				\ ( -- )		mov	r1, [S+8]
:: load1   code load1, ret,

: (or),    rex, 09 ` ;
: or01,    (or), d1 ` ;						\ ( -- )		or	r0, r1
:: or01    code or01, ret,
: or,	   (or), c0 load1 shl1#3 or01 off load1 or01 off ` ;	\ ( rd rs -- )		or	Rd, Rs
:: or	   code load1, r0 r1 or, off, ret,

: (mov),   rex, 89 ` ;
: mov,     (mov), c0 load1 shl1#3 or01 off load1 or01 off ` ;	\ ( rd rs -- )		mov	Rd, Rs

: shl,     rex, d3 ` e0 or ` ;					\ ( rd -- )		shl	Rd, cl
:: shl     code load1, r1 shl, r0 r1 mov, off, ret,		\ ( n u -- u<<n )	mov	r1, [S+8] ; shl r1, r0l ; mov r0, r1 ; inc rstack	
: sar,     rex, d3 ` f8 or ` ;					\ ( rd -- )		sar	Rd, cl
:: sar     code load1, r1 sar, r0 r1 mov, off, ret,		\ ( n u -- u>>n )	mov	r1, [S+8] ; sal r1, r0l ; mov r0, r1 ; inc rstack	

: load,    (load,  3 shl 44 or ` load), ; 			\ ( # rd -- )		mov	Rd, [S+#]
: store,   (store, 3 shl 44 or ` store), ;		 	\ ( # rs -- )		mov	[S+#], Rs

: (add),   rex, 01 ` ;
: (sub),   rex, 29 ` ;
: add,     (add), 3 shl c0 or r0 or ` ;				\ ( rs -- )		add	r0, Rs
: sub,     (sub), c0 or r0 3 shl or ` ;				\ ( rd -- )		sub	Rd, r0
:: +       code #1 r1 load, r1 add, off, ret,			\ ( n1 n2 -- n1+n2 )	mov	r1, [S+8] ; add r0, r1 ; inc rstack
:: -       code #1 r1 load, r1 sub, r0 r1 mov, off, ret,	\ ( n1 n2 -- n1-n2 )	mov	r1, [S+8] ; sub r1, r0 ; mov r0, r1 ; inc rstack

								\ Modern and fancy names for stack manipulation words with visual semantics
:: _       code #1 r0 load, off, ret,				\ ( a -- )		drop
:: |       code on, #1 r0 store, ret,				\ ( a -- a a )		dup
:: ><      code #1 r1 load, #1 r0 store, r0 r1 mov, ret,	\ ( a b -- b a )	swap
:: >|      code #1 r1 load, on, #1 r0 store, r0 r1 mov, ret,	\ ( a b -- a b a )	over
:: >>>     code #1 r1 load, #2 r2 load, 			\ ( a b c -- b c a )	rot
           #2 r1 store, #1 r0 store, r0 r2 mov, ret,
:: <<<     code	#1 r1 load, #2 r2 load,				\ ( a b c -- c a b )	-rot
           #2 r0 store, #1 r2 store, r0 r1 mov, ret,

: dup,     #0 r0 store, on, ;

:: @       code rex, 8b ` 09 ` ret,				\ ( a -- [a] )		mov	r0, [r0]
:: c@      code rex, 0f ` b6 ` 09 ` ret,			\ ( a -- byte [a] )	movzx	r0, byte ptr [r0]

:: !       code #1 r1 load, rex, 89 ` 11 ` off, off,		\ ( n a -- )		mov	r1, [S+8] ; mov [r0], r1 ; inc rstack ; inc rstack 
           #0 r0 load, ret,					\			mov	r0, [S+8]

\ Variables and constants
: var      , does> ;
: val      , does> @ ;

\ Control structures
: cell/	   3 sar ;

: >mark    here 0 , ;						\ ( -- a )		Address for forward branch fixup
: >resolve | here >< - cell/ 1- ><  ! ;				\ ( a -- )		Fixup forward branch

: <mark    here  ;						\ ( -- a )		Address for backward branch fixup
: <resolve here  - cell/ 1- , ;

: if       compile ?branch >mark ; immediate
: else     compile branch >mark >< >resolve ; immediate
: then     >resolve ; immediate

: begin    <mark ; immediate
: until    compile ?branch <resolve ; immediate
: again    compile branch <resolve ; immediate
: while    compile ?branch >mark ; immediate
: repeat   >< compile branch <resolve >resolve ; immediate

