: \ 0 word drop ; immediate
: \\ 0 word drop ; immediate
\
\\ Moore Forth System
\

								\\ Comments and debug output
: norm     1b emit 5b emit 30 emit 6d emit ;
: blue     1b emit 5b emit 33 emit 34 emit 6d emit ;
: red      1b emit 5b emit 33 emit 31 emit 6d emit ;
: white    1b emit 5b emit 33 emit 37 emit 6d emit ;
: .\       0 word count blue type norm 0a emit ;
: abort"   22 word count 0a emit red type norm 0a emit abort ;
: .abort   red . . norm abort ;					\ ( code message -- )	Prints code and message as hexadecimal numbers and aborts
: cr       0a emit ;
: ..       blue . norm ;
: ??       dup .. ;

								\ Compile single byte
: `        c, ;
								\\ Register assignment. Should be changed if register aliases are changed
: r0       01 ;							\ rcx = rtop
: rtop     01 ;
: r1       02 ;							\ rdx = rtmp
: rtmp     02 ;
: r2       00 ;							\ rax = rwork
: rwork    00 ;
: rstate   03 ;							\ rbx = rstate
: rsp      04 ;							\ rsp
: rpc      06 ;							\ rsi = rpc
: rindex   0a ;							\ r10 = rindex
: rend     0c ;							\ r12 = rend

: #0 0 ;							\ Offset of the first available stack item
: #1 8 ;							\ Offset of the second stack item
: #2 10 ;							\ Offset of the third stack item

								\\ Basic assembler for r0-r7. Stack access is hardcoded
: rex,     48 ` ;
: rex1,    49 ` ;

: ret,     c3 ` ;						\ ( -- )		ret

:: 1+      code rex, ff ` c1 ` ret,				\ ( n -- n+1)		inc	r0
:: 1-      code rex, ff ` c9 ` ret,				\ ( n -- n-1)		dec	r0

: shl1,    rex, c1 ` e2 ` ` ;					\ ( n -- )		shl	r0, n
:: shl1#3  code	3 shl1,	ret,					\ ( -- )		shl	r1, 3

: off,     rex, ff ` c5 ` ;					\ ( -- )		inc	rstack
: on,      rex, ff ` cd ` ;					\ ( -- )		dec	rstack
:: off     code off, ret,					\ ( a b -- b )

: (load,   rex1, 8b ` ;
: (store,  rex1, 89 ` ;
: load),   ef ` ` ;
: store),  ef ` ` ;
: load1,   (load, 54 ` #1 load), ;				\ ( -- )		mov	r1, [S+8]
:: load1   code load1, ret,

: (or),    rex, 09 ` ;
: or01,    (or), d1 ` ;						\ ( -- )		or	r0, r1
:: or01    code or01, ret,

: modrm,   c0 load1 shl1#3 or01 off load1 or01 ` ;		\ ( rd rs -- ) Compiles ModR/M byte

: or,	   (or), modrm, ;					\ ( rd rs -- )		or	Rd, Rs
:: or	   code load1, r0 r1 or, off, ret,

: (and),    rex, 21 ` ;
: and,	   (and), modrm, ;					\ ( rd rs -- )		and	Rd, Rs
:: and	   code load1, r0 r1 and, off, ret,

: (mov),   rex, 89 ` ;
: mov,     (mov), modrm, ;					\ ( rd rs -- )		mov	Rd, Rs	# s, d <= 7

: shl,     rex, d3 ` e0 or ` ;					\ ( rd -- )		shl	Rd, cl
:: shl     code load1, r1 shl, r0 r1 mov, off, ret,		\ ( n u -- u<<n )	mov	r1, [S+8] ; shl r1, r0l ; mov r0, r1 ; inc rstack	
: sar,     rex, d3 ` f8 or ` ;					\ ( rd -- )		sar	Rd, cl
:: sar     code load1, r1 sar, r0 r1 mov, off, ret,		\ ( n u -- u>>n )	mov	r1, [S+8] ; sal r1, r0l ; mov r0, r1 ; inc rstack	

: load,    (load,  3 shl 44 or ` load), ; 			\ ( # rd -- )		mov	Rd, [S+#]
: store,   (store, 3 shl 44 or ` store), ;		 	\ ( # rs -- )		mov	[S+#], Rs

								\ Basic subtraction is needed to implement control structures
: (add),   rex, 01 ` ;
: (sub),   rex, 29 ` ;
: add,     (add), 3 shl c0 or r0 or ` ;				\ ( rs -- )		add	r0, Rs
: sub,     (sub), c0 or r0 3 shl or ` ;				\ ( rd -- )		sub	Rd, r0
:: +       code #1 r1 load, r1 add, off, ret,			\ ( n1 n2 -- n1+n2 )	mov	r1, [S+8] ; add r0, r1 ; inc rstack
:: -       code #1 r1 load, r1 sub, r0 r1 mov, off, ret,	\ ( n1 n2 -- n1-n2 )	mov	r1, [S+8] ; sub r1, r0 ; mov r0, r1 ; inc rstack

								\\ Stack manipulation words with modern and fancy names not without visual semantics
: _,       #1 r0 load, off, ;					\ ( a -- )		drop
: |,       #0 r0 store, on, ;					\ ( a -- a a )		dup
: ><,      #1 r1 load, #1 r0 store, r0 r1 mov, ;		\ ( a b -- b a )	swap
: >|,      #1 r1 load, on, #1 r0 store, r0 r1 mov, ;		\ ( a b -- a b a )	over
: >|>|,    #1 r1 load, on, #1 r0 store, on, #1 r1 store, ;	\ ( a b -- a b a b )	2dup = over over
: >>>,     #1 r1 load, #2 r2 load,				\ ( a b c -- b c a )	rot
           #2 r1 store, #1 r0 store, r0 r2 mov, ;
: <<<,     #1 r1 load, #2 r2 load,				\ ( a b c -- c a b )	-rot
           #2 r0 store, #1 r2 store, r0 r1 mov, ;

:: _       code _, ret,
:: |       code |, ret,
:: ><      code ><, ret,
:: >|      code >|, ret,
:: >|>|    code >|>|, ret,
:: >>>     code >>>, ret,
:: <<<     code <<<, ret,

								\\ Memory access words
:: @       code rex, 8b ` 09 ` ret,				\ ( a -- [a] )		mov	r0, [r0]
:: c@      code rex, 0f ` b6 ` 09 ` ret,			\ ( a -- byte [a] )	movzx	r0, byte ptr [r0]

:: !       code #1 r1 load, rex, 89 ` 11 ` off, off,		\ ( n a -- )		mov	r1, [S+8] ; mov [r0], r1 ; inc rstack ; inc rstack 
           #0 r0 load, ret,					\			mov	r0, [S+8]
:: c!      code #1 r1 load, rex, 88 ` 11 ` off, off,		\ ( n a -- )		mov	r1, [S+8] ; mov [r0], r1 ; inc rstack ; inc rstack 
           #0 r0 load, ret,					\			mov	r0, [S+8]

								\\ Variables and constants
: adr      does> ;						\ :: a adr
: var      , does> ;						\ :: a 12345 var
: val      , does> @ ;						\ :: b 98765 val

								\\ Cells
: cell     8 ;							\ ( -- 8 )		Size of one cell
: cells    3 shl ;						\ ( n -- n*8 )		Convert size in cells to size in bytes
: cell/	   3 sar ;						\ ( n -- n/8 )		Convert size in bytes to size in cells

								\\ States
:: INTERPRETING  0 val
:: COMPILING    -2 val
:: DECOMPILING  -4 val
:: REGALLOCING  -6 val
								\\ Dictionary structure
: >cfa     cells + cell - cell - ;				\ ( xt state -- cfa )	Returns CFA for given state for XT
: cfa@     | @ >< cell + @ >< ;					\ ( cfa -- param code )	Returns param and code for CFA
: >cfa@    >cfa cfa@ ;						\ ( xt state -- param code)	Returns param and code for given state for XT

: >name    22 cells - @ ; 					\ ( xt -- c-addr )	Returns address of the name counted string

: >mark    here 0 , ;						\ ( -- a )		Address for forward branch fixup
: >resolve | here >< - cell/ 1- ><  ! ;				\ ( a -- )		Fixup forward branch

: <mark    here  ;						\ ( -- a )		Address for backward branch fixup
: <resolve here  - cell/ 1- , ;

: if       compile ?branch >mark ; immediate
: else     compile branch >mark >< >resolve ; immediate
: then     >resolve ; immediate
: begin    <mark ; immediate
: until    compile ?branch <resolve ; immediate			\ ... begin ... -? until ...
: again    compile branch <resolve ; immediate			\ ... begin ... again ...
: ahead    compile branch >mark ; immediate
: while    compile ?branch >mark ; immediate
: leave    compile ?branch >mark >< ; immediate
: repeat   >< compile branch <resolve >resolve ; immediate	\ ... begin ... ? while ... repeat ...
								\\ Search
: '        bl word _ find | if else abort then ;		\ ("<name>" -- xt | ABORT )
: [compile] ' , ; immediate					\ ("<name>" -- )	Compiles XT of the next word in the input stream

								\\ Improved assembler, r0-15 support 
\\ TODO: need [compile] and " to make this work : rex      abort" REX is now obsolete, use REXn where n=8, 32, 64" ;
: rex      abort ;						\ Obsolete
: rex.     40 ;
: rex.b    rex. ;						\ REX operand size determined by CS.D
: rex.q    rex. 08 or ;						\ REX specifies 64-bit operands
: rex?     08 and ;						\ ( r -- f )	 	Checks if R is an extended regsiter (R8-R15)
: rex.rd   >< rex? if 01 or then ;				\ ( rd rex' -- rex'' )	REX part with Rd bit set
: rex.rs   >< rex? if 04 or then ;				\ ( rd rex' -- rex'' )	REX part with Rd bit set
: rexrr.q  rex.q rex.rs rex.rd ;				\ ( rd rs -- rex )	Returns REX prefix for Rd and Rs
: rexrd.q  rex.q rex.rd ;					\ ( rd -- rex )		Returns REX prefix for Rd
: rexrs.q  rex.q rex.rs ;					\ ( rs -- rex )		Returns REX prefix for Rs
: rd       07 and ;						\ ( rd -- modrm' )	Returns ModR/M byte part for Rd
: rs       07 and 3 shl ;						\ ( rs -- modrm' )	Returns ModR/M byte part for Rs
: rr       c0 ;							\ (  -- modrm' )	Returns ModR/M byte part for RR
: modrr    rs >< rd or rr or ;					\ ( rd rs -- modrm )	Returns ModR/M byte for Rd and Rs
: modro    >< rd or rr or ;					\ ( rd op -- modrm )	Returns ModR/M byte for Rd and opcode
: instrr   c, does> <<< >|>| rexrr.q ` >>> c@ ` modrr ` ;	\ ( op -- ) ( rd rs a -- )
: instro   c, c, does> >< | rexrd.q ` >< | c@ `			\ ( op1 op2 -- ) ( rd a -- )
           1+ c@  modro ` ;
: instroi4 c, c, does> >< <<< >< | rexrd.q ` >< | c@ `		 \ ( op1 op2 -- ) ( rd imm32 a  -- )
           1+ c@  modro ` 4, ;
: instpp   c, does> c@ >< | rex? if 41 ` then 7 and or ` ; 	\ ( op -- ) ( rd a -- )	Push/pop instruction

								\\ Condition codes and conditional set instructions
:: .o      00 val
:: .no     01 val
:: .b      02 val
:: .nae    02 val
:: .nb     03 val
:: .ae     03 val
:: .e      04 val
:: .z      04 val
:: .ne     05 val
:: .nz     05 val
:: .be     06 val
:: .na     06 val
:: .nbe    07 val
:: .a      07 val
:: .s      08 val
:: .ns     09 val
:: .p      0a val
:: .pe     0a val
:: .np     0b val
:: .po     0b val
:: .l      0c val
:: .nge    0c val
:: .nl     0d val
:: .ge     0d val
:: .le     0e val
:: .ng     0e val
:: .nle    0f val
:: .g      0f val

:: setf.op 90 val						\ SETcc opcode
: setf,    rex.b ` 0f ` setf.op or ` rd rr or ` ;		\ ( rd cond -- )	set.cc rd

:: j.op    70 val						\ Jcc opcode
: j,       j.op or ` ` ;					\ ( offset cond -- )	j.cc	offset

								\\ Arithmetic, logic and moves
:: movzx.op b6 val						\ MOVZX opcode
: movzx,   rex.q ` 0f ` movzx.op ` modrr ` ;			\ ( rd rs -- )		movzx	rdl, rs

:: mov,    89 instrr						\ ( rd rs -- )		mov	rd, rs	

:: inc,    00 ff instro						\ ( rd -- )		inc	rd
:: dec,    08 ff instro						\ ( rd -- )		dec	rd

:: mov.i,  00 c7 instroi4					\ ( rd imm32 -- )	mov	rd, imm32

:: push,   50 instpp						\ ( rs -- )		push	rs
:: pop,    58 instpp						\ ( rd -- )		pop	rd

: setnz0,  r0 .nz setf,    48 ` 0f ` b6 ` c9 ` ;		\ 			setnz	cl ; movzx rcx, cl

: lodsq,   48 ` ad ` ;						\			lodsq	rax, qword ptr [rsi]
: rpc+=ofs, 48 ` 8d ` 34 ` c6 ` ;				\			lea	rsi, [rsi + rax*8]
:: skip    code rtmp pop, rwork pop, 				\ ( -- )		Skip next address interpreter word TODO: make single ADD
		rwork inc, rwork inc, rwork inc, rwork inc,
		rwork inc, rwork inc, rwork inc, rwork inc,
		rwork push, rtmp push, ret,
								\\ Return stack
:: >r      code r1 pop, r0 push, _, r1 push, ret,		\ ( a -- ) ( R: -- a)	Pushes top of parameter stack onto return stack
:: r>      code |, r1 pop, r0 pop, r1 push, ret,		\ ( -- a ) ( R: a -- )	Pops top of parameter stack off return stack
								\\ Control structures: loops
:: (for)   code rindex r0 mov, _, ret,				\ ( n -- )		mov	rindex, rtop ; drop
:: I       code |, r0 rindex mov, ret,				\ ( -- I )		Returns FOR loop index
:: (over)  code rindex dec, lodsq, 4 .z j, rpc+=ofs, ret,	\ ( -- )		dec rindex ; lodsq ; jz ret ; rpc+=ofs ; ret
' branch DECOMPILING >cfa@ DECOMPILING latest does

								\ DOC: https://github.com/TG9541/stm8ef/wiki/eForth-FOR-..-NEXT
: for      compile (for) <mark ; immediate			\ ... n for ... [ aft ] ... [ then ] ... over ...
: aft      _ compile branch >mark <mark >< ; immediate
: over     compile (over) <resolve ; immediate

								\\ Data structures
: fill    <<< for >|>| c! over _ _ ;				\ ( a n c -- )	Fill N bytes from address A with character C

